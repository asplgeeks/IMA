{"ast":null,"code":"import { filterProps, createError } from '../utils';\nvar LIST_FORMAT_OPTIONS = ['localeMatcher', 'type', 'style'];\nvar now = Date.now();\n\nfunction generateToken(i) {\n  return \"\".concat(now, \"_\").concat(i, \"_\").concat(now);\n}\n\nexport function formatList(_ref, getListFormat, values) {\n  var locale = _ref.locale,\n      onError = _ref.onError;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var ListFormat = Intl.ListFormat;\n\n  if (!ListFormat) {\n    onError(createError(\"Intl.ListFormat is not available in this environment.\\nTry polyfilling it using \\\"@formatjs/intl-listformat\\\"\\n\"));\n  }\n\n  var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);\n\n  try {\n    var richValues = {};\n    var serializedValues = values.map(function (v, i) {\n      if (typeof v === 'object') {\n        var id = generateToken(i);\n        richValues[id] = v;\n        return id;\n      }\n\n      return String(v);\n    });\n\n    if (!Object.keys(richValues).length) {\n      return getListFormat(locale, filteredOptions).format(serializedValues);\n    }\n\n    var parts = getListFormat(locale, filteredOptions).formatToParts(serializedValues);\n    return parts.reduce(function (all, el) {\n      var val = el.value;\n\n      if (richValues[val]) {\n        all.push(richValues[val]);\n      } else if (typeof all[all.length - 1] === 'string') {\n        all[all.length - 1] += val;\n      } else {\n        all.push(val);\n      }\n\n      return all;\n    }, []);\n  } catch (e) {\n    onError(createError('Error formatting list.', e));\n  }\n\n  return values;\n}","map":{"version":3,"sources":["D:/nodejs/IMA/node_modules/react-intl/lib/formatters/list.js"],"names":["filterProps","createError","LIST_FORMAT_OPTIONS","now","Date","generateToken","i","formatList","getListFormat","values","locale","onError","options","ListFormat","Intl","filteredOptions","richValues","serializedValues","map","v","id","String","Object","keys","length","format","parts","formatToParts","reduce","all","el","val","value","push","e"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,WAAtB,QAAyC,UAAzC;AACA,IAAMC,mBAAmB,GAAG,CACxB,eADwB,EAExB,MAFwB,EAGxB,OAHwB,CAA5B;AAKA,IAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;AACA,SAASE,aAAT,CAAuBC,CAAvB,EAA0B;AACtB,mBAAUH,GAAV,cAAiBG,CAAjB,cAAsBH,GAAtB;AACH;;AACD,OAAO,SAASI,UAAT,OAAyCC,aAAzC,EAAwDC,MAAxD,EAA8E;AAAA,MAAxDC,MAAwD,QAAxDA,MAAwD;AAAA,MAAhDC,OAAgD,QAAhDA,OAAgD;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AACjF,MAAMC,UAAU,GAAGC,IAAI,CAACD,UAAxB;;AACA,MAAI,CAACA,UAAL,EAAiB;AACbF,IAAAA,OAAO,CAACV,WAAW,mHAAZ,CAAP;AAGH;;AACD,MAAMc,eAAe,GAAGf,WAAW,CAACY,OAAD,EAAUV,mBAAV,CAAnC;;AACA,MAAI;AACA,QAAMc,UAAU,GAAG,EAAnB;AACA,QAAMC,gBAAgB,GAAGR,MAAM,CAACS,GAAP,CAAW,UAACC,CAAD,EAAIb,CAAJ,EAAU;AAC1C,UAAI,OAAOa,CAAP,KAAa,QAAjB,EAA2B;AACvB,YAAMC,EAAE,GAAGf,aAAa,CAACC,CAAD,CAAxB;AACAU,QAAAA,UAAU,CAACI,EAAD,CAAV,GAAiBD,CAAjB;AACA,eAAOC,EAAP;AACH;;AACD,aAAOC,MAAM,CAACF,CAAD,CAAb;AACH,KAPwB,CAAzB;;AAQA,QAAI,CAACG,MAAM,CAACC,IAAP,CAAYP,UAAZ,EAAwBQ,MAA7B,EAAqC;AACjC,aAAOhB,aAAa,CAACE,MAAD,EAASK,eAAT,CAAb,CAAuCU,MAAvC,CAA8CR,gBAA9C,CAAP;AACH;;AACD,QAAMS,KAAK,GAAGlB,aAAa,CAACE,MAAD,EAASK,eAAT,CAAb,CAAuCY,aAAvC,CAAqDV,gBAArD,CAAd;AACA,WAAOS,KAAK,CAACE,MAAN,CAAa,UAACC,GAAD,EAAMC,EAAN,EAAa;AAC7B,UAAMC,GAAG,GAAGD,EAAE,CAACE,KAAf;;AACA,UAAIhB,UAAU,CAACe,GAAD,CAAd,EAAqB;AACjBF,QAAAA,GAAG,CAACI,IAAJ,CAASjB,UAAU,CAACe,GAAD,CAAnB;AACH,OAFD,MAGK,IAAI,OAAOF,GAAG,CAACA,GAAG,CAACL,MAAJ,GAAa,CAAd,CAAV,KAA+B,QAAnC,EAA6C;AAC9CK,QAAAA,GAAG,CAACA,GAAG,CAACL,MAAJ,GAAa,CAAd,CAAH,IAAuBO,GAAvB;AACH,OAFI,MAGA;AACDF,QAAAA,GAAG,CAACI,IAAJ,CAASF,GAAT;AACH;;AACD,aAAOF,GAAP;AACH,KAZM,EAYJ,EAZI,CAAP;AAaH,GA3BD,CA4BA,OAAOK,CAAP,EAAU;AACNvB,IAAAA,OAAO,CAACV,WAAW,CAAC,wBAAD,EAA2BiC,CAA3B,CAAZ,CAAP;AACH;;AACD,SAAOzB,MAAP;AACH","sourcesContent":["import { filterProps, createError } from '../utils';\r\nconst LIST_FORMAT_OPTIONS = [\r\n    'localeMatcher',\r\n    'type',\r\n    'style',\r\n];\r\nconst now = Date.now();\r\nfunction generateToken(i) {\r\n    return `${now}_${i}_${now}`;\r\n}\r\nexport function formatList({ locale, onError }, getListFormat, values, options = {}) {\r\n    const ListFormat = Intl.ListFormat;\r\n    if (!ListFormat) {\r\n        onError(createError(`Intl.ListFormat is not available in this environment.\r\nTry polyfilling it using \"@formatjs/intl-listformat\"\r\n`));\r\n    }\r\n    const filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);\r\n    try {\r\n        const richValues = {};\r\n        const serializedValues = values.map((v, i) => {\r\n            if (typeof v === 'object') {\r\n                const id = generateToken(i);\r\n                richValues[id] = v;\r\n                return id;\r\n            }\r\n            return String(v);\r\n        });\r\n        if (!Object.keys(richValues).length) {\r\n            return getListFormat(locale, filteredOptions).format(serializedValues);\r\n        }\r\n        const parts = getListFormat(locale, filteredOptions).formatToParts(serializedValues);\r\n        return parts.reduce((all, el) => {\r\n            const val = el.value;\r\n            if (richValues[val]) {\r\n                all.push(richValues[val]);\r\n            }\r\n            else if (typeof all[all.length - 1] === 'string') {\r\n                all[all.length - 1] += val;\r\n            }\r\n            else {\r\n                all.push(val);\r\n            }\r\n            return all;\r\n        }, []);\r\n    }\r\n    catch (e) {\r\n        onError(createError('Error formatting list.', e));\r\n    }\r\n    return values;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}